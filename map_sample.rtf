{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 <!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.7.5"><title>Resilience IQ</title><!-- Mapbox GL JS CSS and JavaScript --><link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet"><script type="module" src="/_astro/Layout.astro_astro_type_script_index_0_lang.DTOoafvW.js"></script><!-- Google Fonts --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"><!-- D3.js --><script type="module" src="/_astro/Layout.astro_astro_type_script_index_1_lang.CpqzEMls.js"></script><style>#map[data-astro-cid-hosem7cn]\{width:100%;height:100vh;position:absolute;top:0;left:0\}.mapboxgl-popup-content\{padding:15px;border-radius:8px;max-height:400px;overflow-y:auto\}.mapboxgl-popup-content h3\{margin:0 0 10px;font-size:1.2rem;color:#333;border-bottom:1px solid #eee;padding-bottom:8px\}.mapboxgl-popup-content h4\{margin:12px 0 8px;font-size:1rem;color:#444\}.mapboxgl-popup-content p\{margin:5px 0;font-size:.9rem;color:#555\}.cluster-summary\{margin-bottom:15px\}.city-summary\{margin-bottom:12px\}.city-list\{list-style:none;padding-left:5px;margin:12px 0\}.city-item\{margin:8px 0;font-size:.9rem;display:flex;justify-content:space-between;align-items:center\}.city-link\{color:#35f;text-decoration:none;font-weight:500\}.city-link:hover\{text-decoration:underline\}.solution-count\{color:#666;font-size:.85rem;margin-left:8px\}.unknown-city\{color:#888;font-style:italic\}.solution-list\{list-style:none;padding-left:5px;margin:5px 0\}.solution-list li\{margin:4px 0;font-size:.85rem\}.solution-link\{color:#35f;text-decoration:none\}.solution-link:hover\{text-decoration:underline\}.see-more-link\{color:#666;font-style:italic;text-decoration:none\}.see-more-link:hover\{text-decoration:underline\}.popup-description\{margin:10px 0;font-style:italic\}.popup-link,.view-all-link\{display:inline-block;margin-top:10px;padding:5px 10px;background-color:#35f;color:#fff;text-decoration:none;border-radius:4px;font-size:.9rem;transition:background-color .2s\}.popup-link:hover,.view-all-link:hover\{background-color:#24d\}.view-all-link\{display:block;text-align:center;margin-top:15px\}.map-info-panel[data-astro-cid-j7pv25f6]\{position:absolute;bottom:2rem;left:2rem;background:#ffffffe6;backdrop-filter:blur(10px);padding:1.5rem;border-radius:8px;max-width:350px;box-shadow:0 4px 20px #00000026;z-index:10\}h1[data-astro-cid-j7pv25f6]\{font-size:1.8rem;margin:0 0 .5rem;line-height:1.1;color:#1a1a1a\}p[data-astro-cid-j7pv25f6]\{margin:0 0 1.2rem;color:#555;font-size:1rem\}.metric-divider[data-astro-cid-j7pv25f6]\{height:1px;width:100%;background:linear-gradient(to right,transparent,rgba(51,85,255,.3),transparent);margin-bottom:1rem\}.map-stats[data-astro-cid-j7pv25f6]\{display:flex;justify-content:space-around;width:100%;margin-top:.8rem\}.stat[data-astro-cid-j7pv25f6]\{display:flex;flex-direction:column;align-items:center;text-align:center;flex:1\}.stat-number[data-astro-cid-j7pv25f6]\{font-size:2.4rem;font-weight:700;color:#35f;line-height:1.2;margin-bottom:.2rem\}.stat-label[data-astro-cid-j7pv25f6]\{font-size:1rem;color:#555;font-weight:500\}.map-legend[data-astro-cid-j7pv25f6]\{margin-top:1rem\}.map-legend[data-astro-cid-j7pv25f6] h3[data-astro-cid-j7pv25f6]\{font-size:1rem;color:#333;margin:0 0 .8rem\}.legend-items[data-astro-cid-j7pv25f6]\{display:flex;flex-direction:column;gap:.5rem\}.legend-item[data-astro-cid-j7pv25f6]\{display:flex;align-items:center;gap:.5rem\}.legend-dot[data-astro-cid-j7pv25f6]\{width:12px;height:12px;border-radius:50%;border:1px solid #fff\}.legend-dot[data-astro-cid-j7pv25f6].rc100\{background-color:#64748b\}.legend-dot[data-astro-cid-j7pv25f6].c40\{background-color:#a855f7\}.legend-label[data-astro-cid-j7pv25f6]\{font-size:.9rem;color:#555;flex:1\}.legend-symbol[data-astro-cid-j7pv25f6]\{font-size:.8rem;font-weight:500;color:#64748b;background:#f1f5f9;padding:2px 6px;border-radius:4px\}@media (max-width: 768px)\{.map-info-panel[data-astro-cid-j7pv25f6]\{left:1rem;bottom:1rem;padding:1rem;max-width:calc(100% - 2rem)\}h1[data-astro-cid-j7pv25f6]\{font-size:1.5rem\}\} </style> <link rel="stylesheet" href="/_astro/about.Dsyhpcmh.css"></head> <body> <header class="navbar" data-astro-cid-5blmo7yk> <div class="navbar-container" data-astro-cid-5blmo7yk> <div class="navbar-logo" data-astro-cid-5blmo7yk> <a href="/" data-astro-cid-5blmo7yk>Resilience IQ</a> </div> <nav class="navbar-links" data-astro-cid-5blmo7yk> <ul data-astro-cid-5blmo7yk> <li data-astro-cid-5blmo7yk><a href="/solutions" data-astro-cid-5blmo7yk>Solutions</a></li> <li data-astro-cid-5blmo7yk><a href="/cities" data-astro-cid-5blmo7yk>Cities</a></li> <li data-astro-cid-5blmo7yk><a href="/about" data-astro-cid-5blmo7yk>About</a></li> <li data-astro-cid-5blmo7yk><a href="/debug" class="debug-link" data-astro-cid-5blmo7yk>Debug</a></li> </ul> </nav> </div> </header> <script type="module">document.addEventListener("DOMContentLoaded",()=>\{const e=document.querySelector(".dropdown"),o=document.querySelector(".dropdown-toggle");e&&o&&o.addEventListener("click",d=>\{d.preventDefault(),e.classList.toggle("show-dropdown")\})\});</script> <div id="map" data-astro-cid-hosem7cn></div> <script>(function()). then there's three defined dictionaries: solutions, geoHazards, rc100C40Cities // We need to wait for the map container to be available window.onload = function() \{ // Check if mapboxgl is already loaded if (typeof mapboxgl === 'undefined') \{ console.error('Mapbox GL JS is not loaded!'); return; \} try \{ // Access the Mapbox API key mapboxgl.accessToken = "pk.eyJ1IjoiYml0c2FuZGF0b21zIiwiYSI6ImNtOXQ4cGJuNTA5MjcybHEyOTA5bHRrcW0ifQ.HJZF3-kPTrJgvlfyIwwRsg"; // Create the map - centered on western hemisphere at the equator const map = new mapboxgl.Map(\{ container: 'map', style: 'mapbox://styles/mapbox/satellite-v9', // Satellite imagery projection: 'globe', // 3D globe view center: [-90, 0], // Western hemisphere at the equator zoom: 2.2, // Zoomed to see the hemisphere bearing: 0, pitch: 0, minZoom: 2 // Restrict zooming out beyond initial view \}); // Add navigation controls map.addControl(new mapboxgl.NavigationControl()); // Add atmosphere and star effects map.on('style.load', () => \{ map.setFog(\{ color: 'rgb(186, 210, 235)', // sky color 'high-color': 'rgb(36, 92, 223)', // atmosphere color 'horizon-blend': 0.02, 'space-color': 'rgb(11, 11, 25)', 'star-intensity': 0.6 \}); // Add city markers first addCityMarkers(); // Then add solution points on top addSolutionPoints(); \}); // Function to add city markers from geoHazardData function addCityMarkers() \{ // Prepare features for the map const cityFeatures = []; geoHazards.forEach(city => \{ // Check for coordinates in different possible formats const longitude = city.Longitude || city.longitude || city['longitude'] || city['Longitude']; const latitude = city.Latitude || city.latitude || city['latitude'] || city['Latitude']; // Ensure the coordinates are valid numbers const parsedLong = parseFloat(longitude); const parsedLat = parseFloat(latitude); if (!isNaN(parsedLong) && !isNaN(parsedLat)) \{ // Check if city is in RC100 or C40 const rc100C40City = rc100C40Cities.find(c => c.loc_id && String(c.loc_id) === String(city.loc_id) ); const isRC100 = rc100C40City?.rc100 === '1'; const isC40 = rc100C40City?.c40 === '1'; // Create a GeoJSON feature cityFeatures.push(\{ type: 'Feature', geometry: \{ type: 'Point', coordinates: [parsedLong, parsedLat] \}, properties: \{ id: city.id, name: city.Official_Name || city.city_x || 'Unknown City', country: city.Country || city.country || '', population: city.Population || city.population || 0, isRC100, isC40 \} \}); \} \}); // Add the city features collection as a source map.addSource('cities', \{ type: 'geojson', data: \{ type: 'FeatureCollection', features: cityFeatures \} \}); // Add a layer for city markers map.addLayer(\{ id: 'city-markers', type: 'circle', source: 'cities', paint: \{ 'circle-radius': 3, 'circle-color': [ 'case', ['get', 'isRC100'], '#64748b', // RC100 slate ['get', 'isC40'], '#a855f7', // C40 purple '#94a3b8' // Default slate ], 'circle-stroke-width': 1, 'circle-stroke-color': '#e2e8f0', 'circle-opacity': 0.9 \} \}); // Add glow effect for city markers map.addLayer(\{ id: 'city-markers-glow', type: 'circle', source: 'cities', paint: \{ 'circle-radius': 6, 'circle-color': [ 'case', ['get', 'isRC100'], 'rgba(100, 116, 139, 0.3)', // RC100 slate glow ['get', 'isC40'], 'rgba(168, 85, 247, 0.3)', // C40 purple glow 'rgba(148, 163, 184, 0.3)' // Default slate glow ], 'circle-blur': 1, 'circle-opacity': 0.6 \} \}); // Add city labels map.addLayer(\{ id: 'city-labels', type: 'symbol', source: 'cities', layout: \{ 'text-field': ['get', 'name'], 'text-size': 10, 'text-offset': [0, 1.5], 'text-anchor': 'top', 'text-allow-overlap': false, 'text-ignore-placement': false, 'text-optional': true, 'text-justify': 'center', 'text-keep-upright': true, 'text-max-angle': 45, 'text-padding': 2, 'text-letter-spacing': 0.05 \}, paint: \{ 'text-color': '#ffffff', 'text-opacity': 1 \} \}); // Show popup for city markers map.on('click', 'city-markers', (e) => \{ const coordinates = e.features[0].geometry.coordinates.slice(); const properties = e.features[0].properties; // Create popup content for city const popupContent = <h3>$\{properties.name\}</h3> $\{properties.country ? 
\f1\fs26 <p><strong>Country:</strong> $\{properties.country\}</p>
\f0\fs24  : ''\} $\{properties.population ? 
\f1\fs26 <p><strong>Population:</strong> $\{properties.population.toLocaleString()\}</p>
\f0\fs24  : ''\} $\{properties.isRC100 ? '<p><strong>100 Resilient Cities</strong> member</p>' : ''\} $\{properties.isC40 ? '<p><strong>C40 Cities</strong> member</p>' : ''\} <a href="/city/$\{properties.id\}" class="popup-link">View City Details</a> 
\f1\fs26 ; 
\f0\fs24 // Create the popup popup .setLngLat(coordinates) .setHTML(popupContent) .addTo(map); \}); // Change cursor when hovering over city markers map.on('mouseenter', 'city-markers', () => \{ map.getCanvas().style.cursor = 'pointer'; \}); map.on('mouseleave', 'city-markers', () => \{ map.getCanvas().style.cursor = ''; \}); \} // Function to add solution points to the map function addSolutionPoints() \{ // Prepare features for the map const features = []; solutions.forEach(solution => \{ // Check for direct coordinates in the solution const hasDirectCoordinates = solution.longitude && solution.latitude; // Check for coordinates in geoHazardData, handling both upper and lowercase keys const geoHazard = solution.geoHazardData; const hasGeoHazardCoordinates = geoHazard && ( // Check uppercase properties (like API responses) (geoHazard.Longitude && geoHazard.Latitude) || // Check lowercase properties (like transformed data) (geoHazard.longitude && geoHazard.latitude) || // Check latitude/longitude as keys for case-insensitive access (geoHazard['latitude'] && geoHazard['longitude']) || (geoHazard['Latitude'] && geoHazard['Longitude']) ); if (hasDirectCoordinates || hasGeoHazardCoordinates) \{ let longitude, latitude; if (hasDirectCoordinates) \{ // Use direct coordinates from solution longitude = solution.longitude; latitude = solution.latitude; \} else \{ // Use coordinates from geoHazardData, checking different possible casing longitude = geoHazard.Longitude || geoHazard.longitude || geoHazard['longitude'] || geoHazard['Longitude']; latitude = geoHazard.Latitude || geoHazard.latitude || geoHazard['latitude'] || geoHazard['Latitude']; \} // Ensure the coordinates are valid numbers const parsedLong = parseFloat(longitude); const parsedLat = parseFloat(latitude); if (!isNaN(parsedLong) && !isNaN(parsedLat)) \{ // Create a GeoJSON feature features.push(\{ type: 'Feature', geometry: \{ type: 'Point', coordinates: [parsedLong, parsedLat] \}, properties: \{ id: solution.id, title: solution.solution_name || solution.Name || solution.name || 'Unnamed Solution', description: solution.solution_description || solution.Description || solution.description || '', city: solution.city || '', category: Array.isArray(solution.Category) ? solution.Category.join(', ') : (solution.Category || solution.category || '') \} \}); \} \} \}); // Add the features collection as a source map.addSource('solutions', \{ type: 'geojson', data: \{ type: 'FeatureCollection', features: features \}, cluster: true, clusterMaxZoom: 14, // Max zoom to cluster points clusterRadius: 50 // Radius of each cluster when clustering points \}); // Add a layer for the clusters map.addLayer(\{ id: 'clusters', type: 'circle', source: 'solutions', filter: ['has', 'point_count'], paint: \{ // Size circles based on the number of points in the cluster 'circle-radius': [ 'step', ['get', 'point_count'], 25, // size for clusters with < 10 points 10, 35, // size for clusters with < 25 points 25, 45, // size for clusters with < 50 points 50, 60 // size for clusters with >= 50 points ], // Color circles based on the number of points in the cluster 'circle-color': [ 'step', ['get', 'point_count'], 'rgba(255, 167, 38, 0.7)', // Amber/Orange for clusters with < 10 points 10, 'rgba(251, 140, 0, 0.7)', // Darker orange for clusters with < 25 points 25, 'rgba(245, 124, 0, 0.7)', // Even darker orange for clusters with < 50 points 50, 'rgba(230, 81, 0, 0.7)' // Deep orange for clusters with >= 50 points ], 'circle-blur': 0.5, 'circle-opacity': 0.9, 'circle-stroke-width': 1.5, 'circle-stroke-color': [ 'step', ['get', 'point_count'], '#FFA726', // Orange stroke 10, '#FB8C00', 25, '#F57C00', 50, '#E65100' ], 'circle-stroke-opacity': 0.8 \} \}); // Add halo effect for clusters map.addLayer(\{ id: 'cluster-halo', type: 'circle', source: 'solutions', filter: ['has', 'point_count'], paint: \{ 'circle-radius': [ 'step', ['get', 'point_count'], 30, // halo size for clusters with < 10 points 10, 40, // halo size for clusters with < 25 points 25, 50, // halo size for clusters with < 50 points 50, 60 // halo size for clusters with >= 50 points ], 'circle-color': [ 'step', ['get', 'point_count'], 'rgba(255, 167, 38, 0.3)', // Amber/Orange halo 10, 'rgba(251, 140, 0, 0.3)', 25, 'rgba(245, 124, 0, 0.3)', 50, 'rgba(230, 81, 0, 0.3)' ], 'circle-blur': 1.5, 'circle-opacity': [ 'case', ['boolean', ['feature-state', 'hover'], false], 0.8, 0.5 ] \} \}); // Add a layer for the cluster counts map.addLayer(\{ id: 'cluster-count', type: 'symbol', source: 'solutions', filter: ['has', 'point_count'], layout: \{ 'text-field': '\{point_count_abbreviated\}', 'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'], 'text-size': 14 \}, paint: \{ 'text-color': '#ffffff' \} \}); // Add a layer for unclustered points map.addLayer(\{ id: 'unclustered-point', type: 'circle', source: 'solutions', filter: ['!', ['has', 'point_count']], paint: \{ 'circle-radius': 6, 'circle-color': '#FF6B6B', 'circle-stroke-width': 1.5, 'circle-stroke-color': '#fff', 'circle-opacity': 0.9, 'circle-blur': 0.2 \} \}); // Add glow effect for unclustered points map.addLayer(\{ id: 'unclustered-point-glow', type: 'circle', source: 'solutions', filter: ['!', ['has', 'point_count']], paint: \{ 'circle-radius': 12, 'circle-color': 'rgba(255, 107, 107, 0.4)', 'circle-blur': 1, 'circle-opacity': 0.7 \} \}); // Create a popup but don't add it to the map yet const popup = new mapboxgl.Popup(\{ closeButton: true, closeOnClick: true, maxWidth: '350px' \}); // Add event listener to pause rotation when popup opens popup.on('open', () => \{ // Pause rotation when popup opens rotationEnabled = false; \}); // Add event listener to resume rotation when popup closes popup.on('close', () => \{ // Resume rotation when popup closes rotationEnabled = true; \}); // Handle clicks on clusters map.on('click', 'clusters', (e) => \{ const features = map.queryRenderedFeatures(e.point, \{ layers: ['clusters'] \}); const clusterId = features[0].properties.cluster_id; const pointCount = features[0].properties.point_count; const clusterSource = map.getSource('solutions'); // Get the cluster expansion zoom clusterSource.getClusterExpansionZoom(clusterId, (err, zoom) => \{ if (err) return; // Get all points in this cluster clusterSource.getClusterLeaves(clusterId, pointCount, 0, (err, clusterFeatures) => \{ if (err) return; // Process cluster points to create summary // Group solutions by city const citySummary = \{\}; clusterFeatures.forEach(feature => \{ const city = feature.properties.city || 'Unknown'; if (!citySummary[city]) \{ citySummary[city] = \{ count: 0, solutions: [] \}; \} citySummary[city].count++; citySummary[city].solutions.push(\{ id: feature.properties.id, title: feature.properties.title \}); \}); // Get list of cities for URL query parameter const cityNames = Object.keys(citySummary).filter(city => city !== 'Unknown'); const cityQueryString = cityNames.map(city => encodeURIComponent(city)).join(','); // Create a comma-separated list of cities for the popup title const cityTitle = cityNames.length > 0 ? cityNames.join(', ') : 'Unknown Locations'; // Create HTML content for the popup let popupContent = <h3>$\{cityTitle\}</h3> <div class="cluster-summary"> <p>Solutions from the following cities:</p> <ul class="city-list"> 
\f1\fs26 ; 
\f0\fs24 // Add city links Object.keys(citySummary).sort().forEach(city => \{ if (city !== 'Unknown') \{ const cityData = citySummary[city]; // Find the city ID from the geoHazards data const cityInfo = geoHazards.find(hazard => hazard.Official_Name === city || hazard.city_x === city ); // Use the actual city ID from geoHazards or fall back to a hash if not found const cityId = cityInfo ? cityInfo.id : Math.abs(city.split('').reduce((a, b) => \{ a = ((a << 5) - a) + b.charCodeAt(0); return a & a; \}, 0) % 1000); popupContent += <li class="city-item"> <a href="/city/$\{cityId\}" class="city-link">$\{city\}</a> <span class="solution-count">($\{cityData.count\} solution$\{cityData.count !== 1 ? 's' : ''\})</span> </li> 
\f1\fs26 ; 
\f0\fs24 \} \}); // Handle unknown city category if it exists if (citySummary['Unknown'] && citySummary['Unknown'].count > 0) \{ popupContent += <li class="city-item"> <span class="unknown-city">Unspecified location</span> <span class="solution-count">($\{citySummary['Unknown'].count\} solution$\{citySummary['Unknown'].count !== 1 ? 's' : ''\})</span> </li> 
\f1\fs26 ; 
\f0\fs24 \} popupContent += </ul> </div> 
\f1\fs26 ; 
\f0\fs24 // Create the popup at the clicked cluster popup .setLngLat(features[0].geometry.coordinates) .setHTML(popupContent) .addTo(map); \}); \}); \}); // Change cursor when hovering over a cluster map.on('mouseenter', 'clusters', () => \{ map.getCanvas().style.cursor = 'pointer'; \}); map.on('mouseleave', 'clusters', () => \{ map.getCanvas().style.cursor = ''; \}); // Show popup for individual unclustered points map.on('click', 'unclustered-point', (e) => \{ const coordinates = e.features[0].geometry.coordinates.slice(); const properties = e.features[0].properties; // Create popup content for individual solution const popupContent = <h3>$\{properties.title\}</h3> $\{properties.city ? 
\f1\fs26 <p><strong>City:</strong> $\{properties.city\}</p>
\f0\fs24  : ''\} $\{properties.category ? 
\f1\fs26 <p><strong>Category:</strong> $\{properties.category\}</p>
\f0\fs24  : ''\} <p class="popup-description">$\{properties.description ? properties.description.substring(0, 100) + '...' : ''\}</p> <a href="/solution/$\{properties.id\}" class="popup-link">View Details</a> 
\f1\fs26 ; 
\f0\fs24 // Create the popup popup .setLngLat(coordinates) .setHTML(popupContent) .addTo(map); \}); // Change cursor when hovering over an unclustered point map.on('mouseenter', 'unclustered-point', () => \{ map.getCanvas().style.cursor = 'pointer'; \}); map.on('mouseleave', 'unclustered-point', () => \{ map.getCanvas().style.cursor = ''; \}); \} // Variables to track rotation state - SIMPLIFIED VERSION let isUserInteracting = false; let rotationEnabled = true; let rotationAnimationId = null; // Original view settings const originalView = \{ center: [-90, 0], zoom: 2.2, bearing: 0, pitch: 0 \}; // Fixed rotation speed (degrees per second) const ROTATION_SPEED = 6; // 6 degrees per second = full rotation in 60 seconds // Simplified rotation function - goes in ONE direction at a CONSTANT speed function rotateGlobe() \{ if (rotationEnabled && !isUserInteracting) \{ // Get current center const center = map.getCenter(); // Move 0.1 degrees west to east (counterclockwise when viewed from above) const newLng = ((center.lng - 0.1) + 360) % 360; // Update the center with the new longitude, keeping latitude the same map.setCenter([newLng, center.lat]); \} // Continue animation at approximately 60fps (~16.7ms per frame) // This gives us about 6 degrees per second rotation speed rotationAnimationId = setTimeout(rotateGlobe, 16.7); \} // Add interaction tracking and handling map.on('mousedown', () => \{ isUserInteracting = true; rotationEnabled = false; \}); map.on('touchstart', () => \{ isUserInteracting = true; rotationEnabled = false; \}); map.on('mouseup', () => \{ isUserInteracting = false; // Resume rotation after user interaction rotationEnabled = true; \}); map.on('touchend', () => \{ isUserInteracting = false; // Resume rotation after user interaction rotationEnabled = true; \}); // Start rotation when map is loaded map.on('load', () => \{ rotateGlobe(); // Start the simplified rotation // Add pulsing animation effect for clusters let clusterPulseOpacity = 0.7; let pulseDirection = -0.01; // Start by fading out // Animation for pulsing effect on cluster halos function animateClusters() \{ // Update opacity values for the pulse effect clusterPulseOpacity += pulseDirection; // Reverse direction when reaching limits if (clusterPulseOpacity <= 0.3) \{ pulseDirection = 0.01; // Start increasing \} else if (clusterPulseOpacity >= 0.7) \{ pulseDirection = -0.01; // Start decreasing \} // Apply the new opacity to the cluster-halo layer map.setPaintProperty('cluster-halo', 'circle-opacity', [ 'case', ['boolean', ['feature-state', 'hover'], false], 0.8, clusterPulseOpacity ]); // Continue animation requestAnimationFrame(animateClusters); \} // Start the pulsing animation animateClusters(); // Add pulsing animation for individual points too let pointPulseOpacity = 0.7; let pointPulseDirection = -0.01; // Start by fading out function animatePoints() \{ // Update opacity values for the pulse effect (slightly offset from clusters) pointPulseOpacity += pointPulseDirection; // Reverse direction when reaching limits if (pointPulseOpacity <= 0.4) \{ pointPulseDirection = 0.01; // Start increasing \} else if (pointPulseOpacity >= 0.8) \{ pointPulseDirection = -0.01; // Start decreasing \} // Apply the new opacity to the unclustered point glow map.setPaintProperty('unclustered-point-glow', 'circle-opacity', pointPulseOpacity); // Continue animation requestAnimationFrame(animatePoints); \} // Start point animation animatePoints(); \}); \} catch (err) \{ console.error('Error initializing Mapbox map:', err); \} \}; \})();</script> <div class="map-info-panel" data-astro-cid-j7pv25f6> <h1 data-astro-cid-j7pv25f6>How Will Tech Power Urban Adaptation?</h1> <p data-astro-cid-j7pv25f6>We read every city's climate resilience plan so you don't have to. Here's what we found.</p> <div class="metric-divider" data-astro-cid-j7pv25f6></div> <div class="map-stats" data-astro-cid-j7pv25f6> <div class="stat" data-astro-cid-j7pv25f6> <span class="stat-number" data-astro-cid-j7pv25f6>4</span> <span class="stat-label" data-astro-cid-j7pv25f6>Cities</span> </div> <div class="stat" data-astro-cid-j7pv25f6> <span class="stat-number" data-astro-cid-j7pv25f6>222</span> <span class="stat-label" data-astro-cid-j7pv25f6>Solutions</span> </div> </div> <div class="metric-divider" data-astro-cid-j7pv25f6></div> <div class="map-legend" data-astro-cid-j7pv25f6> <h3 data-astro-cid-j7pv25f6>City Networks</h3> <div class="legend-items" data-astro-cid-j7pv25f6> <div class="legend-item" data-astro-cid-j7pv25f6> <span class="legend-dot rc100" data-astro-cid-j7pv25f6></span> <span class="legend-label" data-astro-cid-j7pv25f6>100 Resilient Cities</span> <span class="legend-symbol" data-astro-cid-j7pv25f6>100RC</span> </div> <div class="legend-item" data-astro-cid-j7pv25f6> <span class="legend-dot c40" data-astro-cid-j7pv25f6></span> <span class="legend-label" data-astro-cid-j7pv25f6>C40 Cities</span> <span class="legend-symbol" data-astro-cid-j7pv25f6>C40</span> </div> </div> </div> </div> </body></html>}